// Edit Mode Functionality
let originalTreeData = null;

// Initialize edit mode
function initEditMode() {
    // Store original data for reload
    if (treeData) {
        originalTreeData = JSON.parse(JSON.stringify(treeData));
    }
    
    // Initialize autocomplete fields
    if (typeof initAllAutocompletes === 'function') {
        initAllAutocompletes();
    }
    
    // Mode switching
    const viewModeBtn = document.getElementById('view-mode');
    const editModeBtn = document.getElementById('edit-mode');
    const viewPanel = document.getElementById('view-panel');
    const editPanel = document.getElementById('edit-panel');
    
    viewModeBtn.addEventListener('click', () => {
        viewModeBtn.classList.add('active');
        editModeBtn.classList.remove('active');
        viewPanel.classList.remove('hidden');
        editPanel.classList.add('hidden');
    });
    
    editModeBtn.addEventListener('click', () => {
        editModeBtn.classList.add('active');
        viewModeBtn.classList.remove('active');
        editPanel.classList.remove('hidden');
        viewPanel.classList.add('hidden');
        updateEditForms();
    });
    
    // Enable edit mode button
    editModeBtn.disabled = false;
    
    // Relationship tabs
    const tabBtns = document.querySelectorAll('.tab-btn');
    tabBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            const tab = btn.dataset.tab;
            tabBtns.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            
            document.getElementById('add-parent-child-form').classList.toggle('hidden', tab !== 'parent-child');
            document.getElementById('add-spouse-form').classList.toggle('hidden', tab !== 'spouse');
        });
    });
    
    // Form submissions
    document.getElementById('add-person-form').addEventListener('submit', handleAddPerson);
    document.getElementById('add-parent-child-form').addEventListener('submit', handleAddParentChild);
    document.getElementById('add-spouse-form').addEventListener('submit', handleAddSpouse);
    
    // Download and reload buttons
    document.getElementById('download-json-btn').addEventListener('click', downloadJSON);
    document.getElementById('reload-data-btn').addEventListener('click', reloadOriginalData);
    
    // Auto-generate ID from name
    document.getElementById('person-name-input').addEventListener('input', (e) => {
        const nameInput = e.target;
        const idInput = document.getElementById('person-id-input');
        if (!idInput.value || idInput.dataset.autoGenerated === 'true') {
            const generatedId = generateIdFromName(nameInput.value);
            idInput.value = generatedId;
            idInput.dataset.autoGenerated = 'true';
        }
    });
    
    document.getElementById('person-id-input').addEventListener('input', (e) => {
        e.target.dataset.autoGenerated = 'false';
    });
}

// Generate ID from name
function generateIdFromName(name) {
    if (!name) return '';
    let base = name.toLowerCase().replace(/\s+/g, '_');
    base = base.replace(/[^a-z0-9_]/g, '');
    
    // Check if ID exists
    let counter = 1;
    let finalId = base;
    while (peopleMap[finalId]) {
        finalId = `${base}_${counter}`;
        counter++;
    }
    
    return finalId;
}

// Update edit forms with current data
function updateEditForms() {
    updatePersonSelects();
}

// Update all person select dropdowns (now using autocomplete)
function updatePersonSelects() {
    // Autocomplete fields are updated automatically when peopleMap changes
    // No need to manually update them
}

// Handle add person form submission
function handleAddPerson(e) {
    e.preventDefault();
    
    const name = document.getElementById('person-name-input').value.trim();
    if (!name) {
        showMessage('add-person-form', 'Name is required!', 'error');
        return;
    }
    
    let personId = document.getElementById('person-id-input').value.trim();
    if (!personId) {
        personId = generateIdFromName(name);
    }
    
    // Check if ID already exists
    if (peopleMap[personId]) {
        showMessage('add-person-form', `ID "${personId}" already exists. Please choose a different ID.`, 'error');
        return;
    }
    
    const gender = document.getElementById('person-gender').value || null;
    const aliasesStr = document.getElementById('person-aliases').value.trim();
    const aliases = aliasesStr ? aliasesStr.split(',').map(a => a.trim()).filter(a => a) : [];
    const birthYear = document.getElementById('person-birth-year').value.trim();
    const deathYear = document.getElementById('person-death-year').value.trim();
    const notes = document.getElementById('person-notes').value.trim() || null;
    
    const person = {
        id: personId,
        name: name,
        gender: gender,
        aliases: aliases,
        birthYear: birthYear ? parseInt(birthYear) : null,
        deathYear: deathYear ? parseInt(deathYear) : null,
        notes: notes
    };
    
    // Add to tree data
    treeData.people.push(person);
    peopleMap[personId] = person;
    treeData.meta.modified = new Date().toISOString();
    
    // Reset form
    document.getElementById('add-person-form').reset();
    document.getElementById('person-id-input').dataset.autoGenerated = 'true';
    
    // Update selects
    updatePersonSelects();
    
    // Re-render tree
    renderTree();
    
    showMessage('add-person-form', `Successfully added ${name}!`, 'success');
}

// Check for relationship cycles (e.g., making a child a parent of their parent)
function wouldCreateCycle(parentId, childId) {
    // Build a map of all parent-child relationships
    const parentMap = {};
    relationships.forEach(rel => {
        if (rel.type === 'parentChild') {
            if (!parentMap[rel.childId]) parentMap[rel.childId] = [];
            parentMap[rel.childId].push(rel.parentId);
        }
    });
    
    // Check if childId is an ancestor of parentId
    function isAncestor(ancestorId, descendantId) {
        if (ancestorId === descendantId) return true;
        const parents = parentMap[descendantId] || [];
        for (const parent of parents) {
            if (isAncestor(ancestorId, parent)) return true;
        }
        return false;
    }
    
    return isAncestor(childId, parentId);
}

// Handle add parent-child relationship
function handleAddParentChild(e) {
    e.preventDefault();
    
    const parentId = document.getElementById('parent-select').value;
    const childId = document.getElementById('child-select').value;
    
    if (!parentId || !childId) {
        showMessage('add-parent-child-form', 'Please select both parent and child.', 'error');
        return;
    }
    
    if (parentId === childId) {
        showMessage('add-parent-child-form', 'Parent and child cannot be the same person.', 'error');
        return;
    }
    
    // Check for cycles
    if (wouldCreateCycle(parentId, childId)) {
        const parentName = peopleMap[parentId].name;
        const childName = peopleMap[childId].name;
        const confirmMsg = `Warning: ${childName} is already an ancestor of ${parentName}. Creating this relationship would create a cycle. Do you want to proceed?`;
        if (!confirm(confirmMsg)) {
            return;
        }
    }
    
    // Check if relationship already exists
    const existingIndex = relationships.findIndex(rel => 
        rel.type === 'parentChild' && 
        rel.parentId === parentId && 
        rel.childId === childId
    );
    
    let relationship;
    const biological = document.getElementById('biological-relation').checked;
    const notes = document.getElementById('parent-child-notes').value.trim() || null;
    
    if (existingIndex >= 0) {
        // Relationship exists - ask for confirmation to update
        const parentName = peopleMap[parentId].name;
        const childName = peopleMap[childId].name;
        const existingRel = relationships[existingIndex];
        const confirmMsg = `A relationship between ${parentName} and ${childId} already exists.\n\n` +
            `Current: Biological=${existingRel.biological}, Notes=${existingRel.notes || 'None'}\n` +
            `New: Biological=${biological}, Notes=${notes || 'None'}\n\n` +
            `Do you want to update this relationship?`;
        
        if (!confirm(confirmMsg)) {
            return;
        }
        
        // Update existing relationship
        relationship = relationships[existingIndex];
        relationship.biological = biological;
        relationship.notes = notes;
        
        // Update in treeData
        const treeDataIndex = treeData.relationships.findIndex(rel => 
            rel.type === 'parentChild' && 
            rel.parentId === parentId && 
            rel.childId === childId
        );
        if (treeDataIndex >= 0) {
            treeData.relationships[treeDataIndex] = relationship;
        }
    } else {
        // Create new relationship
        relationship = {
            type: 'parentChild',
            parentId: parentId,
            childId: childId,
            biological: biological,
            notes: notes
        };
        
        relationships.push(relationship);
        treeData.relationships.push(relationship);
    }
    
    treeData.meta.modified = new Date().toISOString();
    
    // Reset form
    document.getElementById('add-parent-child-form').reset();
    document.getElementById('biological-relation').checked = true;
    document.getElementById('parent-search').value = '';
    document.getElementById('child-search').value = '';
    document.getElementById('parent-select').value = '';
    document.getElementById('child-select').value = '';
    
    // Re-render tree
    renderTree();
    
    const parentName = peopleMap[parentId].name;
    const childName = peopleMap[childId].name;
    const action = existingIndex >= 0 ? 'updated' : 'added';
    showMessage('add-parent-child-form', `Successfully ${action} relationship: ${parentName} â†’ ${childName}`, 'success');
}

// Handle add spouse relationship
function handleAddSpouse(e) {
    e.preventDefault();
    
    const spouse1Id = document.getElementById('spouse1-select').value;
    const spouse2Id = document.getElementById('spouse2-select').value;
    
    if (!spouse1Id || !spouse2Id) {
        showMessage('add-spouse-form', 'Please select both spouses.', 'error');
        return;
    }
    
    if (spouse1Id === spouse2Id) {
        showMessage('add-spouse-form', 'A person cannot be their own spouse.', 'error');
        return;
    }
    
    // Check if relationship already exists
    const existingIndex = relationships.findIndex(rel => 
        rel.type === 'spouse' && 
        ((rel.people[0] === spouse1Id && rel.people[1] === spouse2Id) ||
         (rel.people[0] === spouse2Id && rel.people[1] === spouse1Id))
    );
    
    const startYear = document.getElementById('marriage-year').value.trim();
    const endYear = document.getElementById('divorce-year').value.trim();
    const notes = document.getElementById('spouse-notes').value.trim() || null;
    
    let relationship;
    
    if (existingIndex >= 0) {
        // Relationship exists - ask for confirmation to update
        const spouse1Name = peopleMap[spouse1Id].name;
        const spouse2Name = peopleMap[spouse2Id].name;
        const existingRel = relationships[existingIndex];
        const confirmMsg = `A spouse relationship between ${spouse1Name} and ${spouse2Name} already exists.\n\n` +
            `Current: Start=${existingRel.startYear || 'None'}, End=${existingRel.endYear || 'None'}, Notes=${existingRel.notes || 'None'}\n` +
            `New: Start=${startYear || 'None'}, End=${endYear || 'None'}, Notes=${notes || 'None'}\n\n` +
            `Do you want to update this relationship?`;
        
        if (!confirm(confirmMsg)) {
            return;
        }
        
        // Update existing relationship
        relationship = relationships[existingIndex];
        relationship.startYear = startYear ? parseInt(startYear) : null;
        relationship.endYear = endYear ? parseInt(endYear) : null;
        relationship.notes = notes;
        
        // Update in treeData
        const treeDataIndex = treeData.relationships.findIndex(rel => 
            rel.type === 'spouse' && 
            ((rel.people[0] === spouse1Id && rel.people[1] === spouse2Id) ||
             (rel.people[0] === spouse2Id && rel.people[1] === spouse1Id))
        );
        if (treeDataIndex >= 0) {
            treeData.relationships[treeDataIndex] = relationship;
        }
    } else {
        // Create new relationship
        relationship = {
            type: 'spouse',
            people: [spouse1Id, spouse2Id],
            startYear: startYear ? parseInt(startYear) : null,
            endYear: endYear ? parseInt(endYear) : null,
            notes: notes
        };
        
        relationships.push(relationship);
        treeData.relationships.push(relationship);
    }
    
    treeData.meta.modified = new Date().toISOString();
    
    // Reset form
    document.getElementById('add-spouse-form').reset();
    document.getElementById('spouse1-search').value = '';
    document.getElementById('spouse2-search').value = '';
    document.getElementById('spouse1-select').value = '';
    document.getElementById('spouse2-select').value = '';
    
    // Re-render tree
    renderTree();
    
    const spouse1Name = peopleMap[spouse1Id].name;
    const spouse2Name = peopleMap[spouse2Id].name;
    const action = existingIndex >= 0 ? 'updated' : 'added';
    showMessage('add-spouse-form', `Successfully ${action} relationship: ${spouse1Name} & ${spouse2Name}`, 'success');
}

// Show success/error message
function showMessage(formId, message, type) {
    const form = document.getElementById(formId);
    if (!form) return;
    
    const existingMsg = form.querySelector('.success-message, .error-message');
    if (existingMsg) {
        existingMsg.remove();
    }
    
    const msgDiv = document.createElement('div');
    msgDiv.className = type === 'success' ? 'success-message' : 'error-message';
    msgDiv.textContent = message;
    form.appendChild(msgDiv);
    
    // Auto-remove after 5 seconds
    setTimeout(() => {
        msgDiv.remove();
    }, 5000);
}

// Show message in a specific element
function showMessageInElement(element, message, type) {
    if (!element) return;
    
    const existingMsg = element.querySelector('.success-message, .error-message');
    if (existingMsg) {
        existingMsg.remove();
    }
    
    const msgDiv = document.createElement('div');
    msgDiv.className = type === 'success' ? 'success-message' : 'error-message';
    msgDiv.textContent = message;
    element.appendChild(msgDiv);
    
    // Auto-remove after 5 seconds
    setTimeout(() => {
        msgDiv.remove();
    }, 5000);
}

// Download updated JSON
function downloadJSON() {
    if (!treeData) {
        alert('No data to download!');
        return;
    }
    
    const dataStr = JSON.stringify(treeData, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = 'family1.json';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    
    // Show message in the save section
    const saveSection = document.querySelector('.edit-section:last-child');
    showMessageInElement(saveSection, 'JSON file downloaded successfully!', 'success');
}

// Reload original data
function reloadOriginalData() {
    if (!originalTreeData) {
        alert('No original data to reload!');
        return;
    }
    
    if (confirm('Are you sure you want to reload the original data? All unsaved changes will be lost.')) {
        treeData = JSON.parse(JSON.stringify(originalTreeData));
        
        // Rebuild people map
        peopleMap = {};
        treeData.people.forEach(person => {
            peopleMap[person.id] = person;
        });
        
        relationships = treeData.relationships;
        rootPersonId = treeData.meta.rootPersonId || treeData.people[0].id;
        
        // Update forms
        updateEditForms();
        
        // Re-render tree
        renderTree();
        
        const saveSection = document.querySelector('.edit-section:last-child');
        showMessageInElement(saveSection, 'Original data reloaded successfully!', 'success');
    }
}

// Initialize edit mode when tree data is loaded
function waitForTreeData() {
    if (typeof treeData !== 'undefined' && treeData !== null) {
        initEditMode();
    } else {
        // Wait a bit and try again
        setTimeout(waitForTreeData, 100);
    }
}

// Start waiting for tree data
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', waitForTreeData);
} else {
    waitForTreeData();
}

