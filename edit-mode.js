// Edit Mode Functionality
let originalTreeData = null;

// Initialize edit mode
function initEditMode() {
    // Store original data for reload
    if (treeData) {
        originalTreeData = JSON.parse(JSON.stringify(treeData));
    }

    // Initialize autocomplete fields
    if (typeof initAllAutocompletes === 'function') {
        initAllAutocompletes();
    }

    // Mode switching
    const viewModeBtn = document.getElementById('view-mode');
    const editModeBtn = document.getElementById('edit-mode');
    const viewPanel = document.getElementById('view-panel');
    const editPanel = document.getElementById('edit-panel');

    viewModeBtn.addEventListener('click', () => {
        viewModeBtn.classList.add('active');
        editModeBtn.classList.remove('active');
        viewPanel.classList.remove('hidden');
        editPanel.classList.add('hidden');
    });

    editModeBtn.addEventListener('click', () => {
        editModeBtn.classList.add('active');
        viewModeBtn.classList.remove('active');
        editPanel.classList.remove('hidden');
        viewPanel.classList.add('hidden');
        updateEditForms();
    });

    // Enable edit mode button
    editModeBtn.disabled = false;

    // Relationship tabs
    const tabBtns = document.querySelectorAll('.tab-btn');
    tabBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            const tab = btn.dataset.tab;
            tabBtns.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            document.getElementById('add-parent-child-form').classList.toggle('hidden', tab !== 'parent-child');
            document.getElementById('add-spouse-form').classList.toggle('hidden', tab !== 'spouse');
        });
    });

    // Form submissions
    const editBtn = document.getElementById('edit-mode');
    if (editBtn) {
        editBtn.addEventListener('click', toggleEditMode);
    }

    // Forms
    const addParentChildForm = document.getElementById('add-parent-child-form');
    if (addParentChildForm) {
        addParentChildForm.addEventListener('submit', handleAddParentChild);
    }

    const addSpouseForm = document.getElementById('add-spouse-form');
    if (addSpouseForm) {
        addSpouseForm.addEventListener('submit', handleAddSpouse);
    }

    const addPersonForm = document.getElementById('add-person-form');
    if (addPersonForm) {
        addPersonForm.addEventListener('submit', handleAddPerson); // Ensure this handler exists or was added
    }

    const editPersonForm = document.getElementById('edit-person-form');
    if (editPersonForm) {
        editPersonForm.addEventListener('submit', handleUpdatePerson); // Changed to handleUpdatePerson as per existing code
    }

    // Save Buttons
    const saveServerBtn = document.getElementById('save-server-btn');
    if (saveServerBtn) {
        saveServerBtn.addEventListener('click', saveToServer);
    }

    const downloadJsonBtn = document.getElementById('download-json-btn');
    if (downloadJsonBtn) {
        downloadJsonBtn.addEventListener('click', downloadJSON);
    }

    const reloadBtn = document.getElementById('reload-data-btn');
    if (reloadBtn) {
        reloadBtn.addEventListener('click', reloadOriginalData);
    }

    // Tabs
    const tabs = document.querySelectorAll('.tab-btn');
    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            tabs.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            const target = tab.dataset.tab;
            document.querySelectorAll('.edit-form-section').forEach(section => {
                section.classList.remove('active');
            });
            // Assuming sections are named like 'parent-child-section', 'spouse-section', etc.
            const targetSection = document.getElementById(target + '-section');
            if (targetSection) {
                targetSection.classList.add('active');
            } else {
                // Fallback for existing forms if sections are not defined
                document.getElementById('add-parent-child-form').classList.toggle('hidden', target !== 'parent-child');
                document.getElementById('add-spouse-form').classList.toggle('hidden', target !== 'spouse');
                document.getElementById('add-person-form').classList.toggle('hidden', target !== 'add-person'); // Assuming an 'add-person' tab
                document.getElementById('edit-person-form').classList.toggle('hidden', target !== 'edit-person'); // Assuming an 'edit-person' tab
            }
        });
    });

    // Auto-generate ID from name
    document.getElementById('person-name-input').addEventListener('input', (e) => {
        const nameInput = e.target;
        const idInput = document.getElementById('person-id-input');
        if (!idInput.value || idInput.dataset.autoGenerated === 'true') {
            const generatedId = generateIdFromName(nameInput.value);
            idInput.value = generatedId;
            idInput.dataset.autoGenerated = 'true';
        }
    });

    document.getElementById('person-id-input').addEventListener('input', (e) => {
        e.target.dataset.autoGenerated = 'false';
    });

    // --- NEW: Edit Existing Person Listeners ---

    // Initialize Autocomplete for Edit Search
    if (typeof initAutocomplete === 'function') {
        initAutocomplete('edit-search-input', 'edit-search-select', 'edit-search-results', (person) => {
            if (person && person.id) {
                const fullPersonData = peopleMap[person.id];
                loadPersonForEditing(fullPersonData);
            }
        });
    }

    // Handle Edit Form Submission
    const editForm = document.getElementById('edit-person-form');
    if (editForm) {
        editForm.addEventListener('submit', handleUpdatePerson);
    }

    // Handle Cancel Button
    const cancelBtn = document.getElementById('cancel-edit-btn');
    if (cancelBtn) {
        cancelBtn.addEventListener('click', () => {
            document.getElementById('edit-person-form').classList.add('hidden');
            document.getElementById('edit-search-input').value = '';
            document.getElementById('edit-search-select').value = '';
        });
    }
}

// Load Person Data into Edit Form
function loadPersonForEditing(person) {
    document.getElementById('edit-person-form').classList.remove('hidden');
    document.getElementById('edit-person-id').value = person.id;
    document.getElementById('edit-person-name').value = person.name;
    document.getElementById('edit-person-gender').value = person.gender || 'M';
    document.getElementById('edit-person-aliases').value = person.aliases ? person.aliases.join(', ') : '';
    document.getElementById('edit-person-birth-year').value = person.birthYear || '';
    document.getElementById('edit-person-death-year').value = person.deathYear || '';
    document.getElementById('edit-person-notes').value = person.notes || '';

    // Scroll to form
    document.getElementById('edit-person-form').scrollIntoView({ behavior: 'smooth' });
}

// Handle Update Person
function handleUpdatePerson(e) {
    e.preventDefault();

    const id = document.getElementById('edit-person-id').value;
    const person = peopleMap[id];
    if (!person) return;

    // Update fields
    person.name = document.getElementById('edit-person-name').value.trim();
    person.gender = document.getElementById('edit-person-gender').value;

    const aliasesStr = document.getElementById('edit-person-aliases').value.trim();
    person.aliases = aliasesStr ? aliasesStr.split(',').map(a => a.trim()).filter(a => a) : [];

    const bYear = document.getElementById('edit-person-birth-year').value.trim();
    person.birthYear = bYear ? parseInt(bYear) : null;

    const dYear = document.getElementById('edit-person-death-year').value.trim();
    person.deathYear = dYear ? parseInt(dYear) : null;

    person.notes = document.getElementById('edit-person-notes').value.trim() || null;

    treeData.meta.modified = new Date().toISOString();

    // Find index and update treeData.people array as well (peopleMap is reference, but safe to be sure)
    const index = treeData.people.findIndex(p => p.id === id);
    if (index !== -1) treeData.people[index] = person;

    renderTree();
    showMessage('edit-person-form', `Updated ${person.name} successfully!`, 'success');

    // Clear search
    document.getElementById('edit-search-input').value = '';
    document.getElementById('edit-person-form').classList.add('hidden');
}

// Generate ID from name
function generateIdFromName(name) {
    if (!name) return '';
    let base = name.toLowerCase().replace(/\s+/g, '_');
    base = base.replace(/[^a-z0-9_]/g, '');

    // Check if ID exists
    let counter = 1;
    let finalId = base;
    while (peopleMap[finalId]) {
        finalId = `${base}_${counter}`;
        counter++;
    }

    return finalId;
}

// Update edit forms with current data
function updateEditForms() {
    updatePersonSelects();
}

// Update all person select dropdowns (now using autocomplete)
function updatePersonSelects() {
    // Autocomplete fields are updated automatically when peopleMap changes
    // No need to manually update them
}

// --- NEW: Edit Person Functions ---

function loadPersonForEditing(person) {
    if (!person) return;

    const form = document.getElementById('edit-person-form');
    form.classList.remove('hidden');

    document.getElementById('edit-person-id').value = person.id;
    document.getElementById('edit-person-name').value = person.name;
    document.getElementById('edit-person-gender').value = person.gender || 'M';
    document.getElementById('edit-person-aliases').value = person.aliases ? person.aliases.join(', ') : '';
    document.getElementById('edit-person-birth-year').value = person.birthYear || '';
    document.getElementById('edit-person-death-year').value = person.deathYear || '';
    document.getElementById('edit-person-notes').value = person.notes || '';

    // Smooth scroll to form to make it visible
    form.scrollIntoView({ behavior: 'smooth', block: 'center' });
}

function handleUpdatePerson(e) {
    e.preventDefault();

    const id = document.getElementById('edit-person-id').value;
    const person = peopleMap[id];

    if (!person) {
        showMessage('edit-person-form', 'Error: Person not found!', 'error');
        return;
    }

    // Update fields from form
    person.name = document.getElementById('edit-person-name').value.trim();
    person.gender = document.getElementById('edit-person-gender').value;

    const aliasesStr = document.getElementById('edit-person-aliases').value.trim();
    person.aliases = aliasesStr ? aliasesStr.split(',').map(a => a.trim()).filter(a => a) : [];

    const bYear = document.getElementById('edit-person-birth-year').value.trim();
    person.birthYear = bYear ? parseInt(bYear) : null;

    const dYear = document.getElementById('edit-person-death-year').value.trim();
    person.deathYear = dYear ? parseInt(dYear) : null;

    person.notes = document.getElementById('edit-person-notes').value.trim() || null;

    // Update modification time
    treeData.meta.modified = new Date().toISOString();

    // Update array in treeData (peopleMap is already a reference to objects in this array, but good to be safe)
    // Since we modified the object directly via 'person', it is updated in the array too.

    // Re-render to show changes
    renderTree();

    showMessage('edit-person-form', `Updated ${person.name} successfully!`, 'success');

    // Reset and hide
    document.getElementById('edit-search-input').value = '';
    document.getElementById('edit-search-select').value = '';
    document.getElementById('edit-person-form').classList.add('hidden');
}

// Handle add person form submission
function handleAddPerson(e) {
    e.preventDefault();

    const name = document.getElementById('person-name-input').value.trim();
    if (!name) {
        showMessage('add-person-form', 'Name is required!', 'error');
        return;
    }

    let personId = document.getElementById('person-id-input').value.trim();
    if (!personId) {
        personId = generateIdFromName(name);
    }

    // Check if ID already exists
    if (peopleMap[personId]) {
        showMessage('add-person-form', `ID "${personId}" already exists. Please choose a different ID.`, 'error');
        return;
    }

    const gender = document.getElementById('person-gender').value || null;
    const aliasesStr = document.getElementById('person-aliases').value.trim();
    const aliases = aliasesStr ? aliasesStr.split(',').map(a => a.trim()).filter(a => a) : [];
    const birthYear = document.getElementById('person-birth-year').value.trim();
    const deathYear = document.getElementById('person-death-year').value.trim();
    const notes = document.getElementById('person-notes').value.trim() || null;

    const person = {
        id: personId,
        name: name,
        gender: gender,
        aliases: aliases,
        birthYear: birthYear ? parseInt(birthYear) : null,
        deathYear: deathYear ? parseInt(deathYear) : null,
        notes: notes
    };

    // Add to tree data
    treeData.people.push(person);
    peopleMap[personId] = person;
    treeData.meta.modified = new Date().toISOString();

    // Reset form
    document.getElementById('add-person-form').reset();
    document.getElementById('person-id-input').dataset.autoGenerated = 'true';

    // Update selects
    updatePersonSelects();

    // Re-render tree
    renderTree();

    showMessage('add-person-form', `Successfully added ${name}!`, 'success');
}

// Check for relationship cycles (e.g., making a child a parent of their parent)
function wouldCreateCycle(parentId, childId) {
    // Build a map of all parent-child relationships
    const parentMap = {};
    relationships.forEach(rel => {
        if (rel.type === 'parentChild') {
            if (!parentMap[rel.childId]) parentMap[rel.childId] = [];
            parentMap[rel.childId].push(rel.parentId);
        }
    });

    // Check if childId is an ancestor of parentId
    function isAncestor(ancestorId, descendantId) {
        if (ancestorId === descendantId) return true;
        const parents = parentMap[descendantId] || [];
        for (const parent of parents) {
            if (isAncestor(ancestorId, parent)) return true;
        }
        return false;
    }

    return isAncestor(childId, parentId);
}

// Handle add parent-child relationship
function handleAddParentChild(e) {
    e.preventDefault();

    const parentId = document.getElementById('parent-select').value;
    const childId = document.getElementById('child-select').value;

    if (!parentId || !childId) {
        showMessage('add-parent-child-form', 'Please select both parent and child.', 'error');
        return;
    }

    if (parentId === childId) {
        showMessage('add-parent-child-form', 'Parent and child cannot be the same person.', 'error');
        return;
    }

    // Check for cycles
    if (wouldCreateCycle(parentId, childId)) {
        const parentName = peopleMap[parentId].name;
        const childName = peopleMap[childId].name;
        const confirmMsg = `Warning: ${childName} is already an ancestor of ${parentName}. Creating this relationship would create a cycle. Do you want to proceed?`;
        if (!confirm(confirmMsg)) {
            return;
        }
    }

    // Check if relationship already exists
    const existingIndex = relationships.findIndex(rel =>
        rel.type === 'parentChild' &&
        rel.parentId === parentId &&
        rel.childId === childId
    );

    let relationship;
    const biological = document.getElementById('biological-relation').checked;
    const notes = document.getElementById('parent-child-notes').value.trim() || null;

    if (existingIndex >= 0) {
        // Relationship exists - ask for confirmation to update
        const parentName = peopleMap[parentId].name;
        const childName = peopleMap[childId].name;
        const existingRel = relationships[existingIndex];
        const confirmMsg = `A relationship between ${parentName} and ${childId} already exists.\n\n` +
            `Current: Biological=${existingRel.biological}, Notes=${existingRel.notes || 'None'}\n` +
            `New: Biological=${biological}, Notes=${notes || 'None'}\n\n` +
            `Do you want to update this relationship?`;

        if (!confirm(confirmMsg)) {
            return;
        }

        // Update existing relationship
        relationship = relationships[existingIndex];
        relationship.biological = biological;
        relationship.notes = notes;

        // Update in treeData
        const treeDataIndex = treeData.relationships.findIndex(rel =>
            rel.type === 'parentChild' &&
            rel.parentId === parentId &&
            rel.childId === childId
        );
        if (treeDataIndex >= 0) {
            treeData.relationships[treeDataIndex] = relationship;
        }
    } else {
        // Create new relationship
        relationship = {
            type: 'parentChild',
            parentId: parentId,
            childId: childId,
            biological: biological,
            notes: notes
        };

        relationships.push(relationship);
        treeData.relationships.push(relationship);
    }

    treeData.meta.modified = new Date().toISOString();

    // Reset form
    document.getElementById('add-parent-child-form').reset();
    document.getElementById('biological-relation').checked = true;
    document.getElementById('parent-search').value = '';
    document.getElementById('child-search').value = '';
    document.getElementById('parent-select').value = '';
    document.getElementById('child-select').value = '';

    // Re-render tree
    renderTree();

    const parentName = peopleMap[parentId].name;
    const childName = peopleMap[childId].name;
    const action = existingIndex >= 0 ? 'updated' : 'added';
    showMessage('add-parent-child-form', `Successfully ${action} relationship: ${parentName} → ${childName}`, 'success');
}

// Handle add spouse relationship
function handleAddSpouse(e) {
    e.preventDefault();

    const spouse1Id = document.getElementById('spouse1-select').value;
    const spouse2Id = document.getElementById('spouse2-select').value;

    if (!spouse1Id || !spouse2Id) {
        showMessage('add-spouse-form', 'Please select both spouses.', 'error');
        return;
    }

    if (spouse1Id === spouse2Id) {
        showMessage('add-spouse-form', 'A person cannot be their own spouse.', 'error');
        return;
    }

    // Check if relationship already exists
    const existingIndex = relationships.findIndex(rel =>
        rel.type === 'spouse' &&
        ((rel.people[0] === spouse1Id && rel.people[1] === spouse2Id) ||
            (rel.people[0] === spouse2Id && rel.people[1] === spouse1Id))
    );

    const startYear = document.getElementById('marriage-year').value.trim();
    const endYear = document.getElementById('divorce-year').value.trim();
    const notes = document.getElementById('spouse-notes').value.trim() || null;

    let relationship;

    if (existingIndex >= 0) {
        // Relationship exists - ask for confirmation to update
        const spouse1Name = peopleMap[spouse1Id].name;
        const spouse2Name = peopleMap[spouse2Id].name;
        const existingRel = relationships[existingIndex];
        const confirmMsg = `A spouse relationship between ${spouse1Name} and ${spouse2Name} already exists.\n\n` +
            `Current: Start=${existingRel.startYear || 'None'}, End=${existingRel.endYear || 'None'}, Notes=${existingRel.notes || 'None'}\n` +
            `New: Start=${startYear || 'None'}, End=${endYear || 'None'}, Notes=${notes || 'None'}\n\n` +
            `Do you want to update this relationship?`;

        if (!confirm(confirmMsg)) {
            return;
        }

        // Update existing relationship
        relationship = relationships[existingIndex];
        relationship.startYear = startYear ? parseInt(startYear) : null;
        relationship.endYear = endYear ? parseInt(endYear) : null;
        relationship.notes = notes;

        // Update in treeData
        const treeDataIndex = treeData.relationships.findIndex(rel =>
            rel.type === 'spouse' &&
            ((rel.people[0] === spouse1Id && rel.people[1] === spouse2Id) ||
                (rel.people[0] === spouse2Id && rel.people[1] === spouse1Id))
        );
        if (treeDataIndex >= 0) {
            treeData.relationships[treeDataIndex] = relationship;
        }
    } else {
        // Create new relationship
        relationship = {
            type: 'spouse',
            people: [spouse1Id, spouse2Id],
            startYear: startYear ? parseInt(startYear) : null,
            endYear: endYear ? parseInt(endYear) : null,
            notes: notes
        };

        relationships.push(relationship);
        treeData.relationships.push(relationship);
    }

    treeData.meta.modified = new Date().toISOString();

    // Reset form
    document.getElementById('add-spouse-form').reset();
    document.getElementById('spouse1-search').value = '';
    document.getElementById('spouse2-search').value = '';
    document.getElementById('spouse1-select').value = '';
    document.getElementById('spouse2-select').value = '';

    // Re-render tree
    renderTree();

    const spouse1Name = peopleMap[spouse1Id].name;
    const spouse2Name = peopleMap[spouse2Id].name;
    const action = existingIndex >= 0 ? 'updated' : 'added';
    showMessage('add-spouse-form', `Successfully ${action} relationship: ${spouse1Name} & ${spouse2Name}`, 'success');
}

// Show success/error message
function showMessage(formId, message, type) {
    const form = document.getElementById(formId);
    if (!form) return;

    const existingMsg = form.querySelector('.success-message, .error-message');
    if (existingMsg) {
        existingMsg.remove();
    }

    const msgDiv = document.createElement('div');
    msgDiv.className = type === 'success' ? 'success-message' : 'error-message';
    msgDiv.textContent = message;
    form.appendChild(msgDiv);

    // Auto-remove after 5 seconds
    setTimeout(() => {
        msgDiv.remove();
    }, 5000);
}

// Show message in a specific element
function showMessageInElement(element, message, type) {
    if (!element) return;

    const existingMsg = element.querySelector('.success-message, .error-message');
    if (existingMsg) {
        existingMsg.remove();
    }

    const msgDiv = document.createElement('div');
    msgDiv.className = type === 'success' ? 'success-message' : 'error-message';
    msgDiv.textContent = message;
    element.appendChild(msgDiv);

    // Auto-remove after 5 seconds
    setTimeout(() => {
        msgDiv.remove();
    }, 5000);
}


// Save to Server (POST request)
async function saveToServer() {
    if (!treeData) {
        alert('No data to save!');
        return;
    }

    const saveSection = document.querySelector('.edit-section:last-child');
    const msgContainer = saveSection || document.body;

    try {
        const response = await fetch('/save', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(treeData, null, 2) // Pretty print
        });

        if (response.ok) {
            showMessageInElement(msgContainer, '✅ Saved to family1.json successfully!', 'success');
        } else {
            const err = await response.json();
            throw new Error(err.message || 'Unknown server error');
        }
    } catch (error) {
        console.error("Save failed:", error);
        showMessageInElement(msgContainer, `❌ Save Failed: ${error.message}. Make sure server.py is running!`, 'error');
    }
}

// Download JSON (Client-side)
function downloadJSON() {
    if (!treeData) {
        alert('No data to download!');
        return;
    }

    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(treeData, null, 2));
    const downloadAnchorNode = document.createElement('a');
    downloadAnchorNode.setAttribute("href", dataStr);
    downloadAnchorNode.setAttribute("download", "family1.json");
    document.body.appendChild(downloadAnchorNode); // Required for firefox
    downloadAnchorNode.click();
    downloadAnchorNode.remove();
}

// Reload original data
function reloadOriginalData() {
    if (!originalTreeData) {
        alert('No original data to reload!');
        return;
    }

    if (confirm('Are you sure you want to reload the original data? All unsaved changes will be lost.')) {
        treeData = JSON.parse(JSON.stringify(originalTreeData));

        // Rebuild people map
        peopleMap = {};
        treeData.people.forEach(person => {
            peopleMap[person.id] = person;
        });

        relationships = treeData.relationships;
        rootPersonId = treeData.meta.rootPersonId || treeData.people[0].id;

        // Update forms
        updateEditForms();

        // Re-render tree
        renderTree();

        const saveSection = document.querySelector('.edit-section:last-child');
        showMessageInElement(saveSection, 'Original data reloaded successfully!', 'success');
    }
}

// Initialize edit mode when tree data is loaded
function waitForTreeData() {
    if (typeof treeData !== 'undefined' && treeData !== null) {
        initEditMode();
    } else {
        // Wait a bit and try again
        setTimeout(waitForTreeData, 100);
    }
}

// Start waiting for tree data
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', waitForTreeData);
} else {
    waitForTreeData();
}

